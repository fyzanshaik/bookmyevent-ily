// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package bookings

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPayment = `-- name: CreatePayment :one

INSERT INTO payments (
    booking_id, user_id, event_id, amount, currency, 
    payment_method, payment_gateway, gateway_transaction_id, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at
`

type CreatePaymentParams struct {
	BookingID            uuid.UUID      `json:"booking_id"`
	UserID               uuid.UUID      `json:"user_id"`
	EventID              uuid.UUID      `json:"event_id"`
	Amount               string         `json:"amount"`
	Currency             sql.NullString `json:"currency"`
	PaymentMethod        sql.NullString `json:"payment_method"`
	PaymentGateway       sql.NullString `json:"payment_gateway"`
	GatewayTransactionID sql.NullString `json:"gateway_transaction_id"`
	Status               string         `json:"status"`
}

// Payment operations
func (q *Queries) CreatePayment(ctx context.Context, db DBTX, arg CreatePaymentParams) (Payment, error) {
	row := db.QueryRowContext(ctx, createPayment,
		arg.BookingID,
		arg.UserID,
		arg.EventID,
		arg.Amount,
		arg.Currency,
		arg.PaymentMethod,
		arg.PaymentGateway,
		arg.GatewayTransactionID,
		arg.Status,
	)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventPayments = `-- name: GetEventPayments :many
SELECT payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at FROM payments 
WHERE event_id = $1 AND status = 'completed'
ORDER BY completed_at DESC 
LIMIT $2 OFFSET $3
`

type GetEventPaymentsParams struct {
	EventID uuid.UUID `json:"event_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) GetEventPayments(ctx context.Context, db DBTX, arg GetEventPaymentsParams) ([]Payment, error) {
	rows, err := db.QueryContext(ctx, getEventPayments, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.PaymentID,
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentGateway,
			&i.GatewayTransactionID,
			&i.Status,
			&i.TicketUrl,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByBookingID = `-- name: GetPaymentByBookingID :one
SELECT payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at FROM payments WHERE booking_id = $1
`

func (q *Queries) GetPaymentByBookingID(ctx context.Context, db DBTX, bookingID uuid.UUID) (Payment, error) {
	row := db.QueryRowContext(ctx, getPaymentByBookingID, bookingID)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByGatewayTransactionID = `-- name: GetPaymentByGatewayTransactionID :one
SELECT payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at FROM payments WHERE gateway_transaction_id = $1
`

func (q *Queries) GetPaymentByGatewayTransactionID(ctx context.Context, db DBTX, gatewayTransactionID sql.NullString) (Payment, error) {
	row := db.QueryRowContext(ctx, getPaymentByGatewayTransactionID, gatewayTransactionID)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at FROM payments WHERE payment_id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, db DBTX, paymentID uuid.UUID) (Payment, error) {
	row := db.QueryRowContext(ctx, getPaymentByID, paymentID)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentsForAnalytics = `-- name: GetPaymentsForAnalytics :many
SELECT 
    event_id,
    COUNT(*) as total_payments,
    SUM(amount) as total_revenue,
    AVG(amount) as average_amount
FROM payments 
WHERE status = 'completed' 
    AND completed_at >= $1 
    AND completed_at <= $2
GROUP BY event_id
ORDER BY total_revenue DESC
`

type GetPaymentsForAnalyticsParams struct {
	CompletedAt   sql.NullTime `json:"completed_at"`
	CompletedAt_2 sql.NullTime `json:"completed_at_2"`
}

type GetPaymentsForAnalyticsRow struct {
	EventID       uuid.UUID `json:"event_id"`
	TotalPayments int64     `json:"total_payments"`
	TotalRevenue  int64     `json:"total_revenue"`
	AverageAmount float64   `json:"average_amount"`
}

func (q *Queries) GetPaymentsForAnalytics(ctx context.Context, db DBTX, arg GetPaymentsForAnalyticsParams) ([]GetPaymentsForAnalyticsRow, error) {
	rows, err := db.QueryContext(ctx, getPaymentsForAnalytics, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsForAnalyticsRow{}
	for rows.Next() {
		var i GetPaymentsForAnalyticsRow
		if err := rows.Scan(
			&i.EventID,
			&i.TotalPayments,
			&i.TotalRevenue,
			&i.AverageAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPaymentHistory = `-- name: GetUserPaymentHistory :many
SELECT 
    p.payment_id, p.booking_id, p.user_id, p.event_id, p.amount, p.currency, p.payment_method, p.payment_gateway, p.gateway_transaction_id, p.status, p.ticket_url, p.initiated_at, p.completed_at, p.failed_at, p.error_message, p.created_at, p.updated_at,
    b.booking_reference,
    b.quantity,
    b.event_id
FROM payments p
JOIN bookings b ON p.booking_id = b.booking_id
WHERE p.user_id = $1
ORDER BY p.completed_at DESC 
LIMIT $2 OFFSET $3
`

type GetUserPaymentHistoryParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetUserPaymentHistoryRow struct {
	PaymentID            uuid.UUID      `json:"payment_id"`
	BookingID            uuid.UUID      `json:"booking_id"`
	UserID               uuid.UUID      `json:"user_id"`
	EventID              uuid.UUID      `json:"event_id"`
	Amount               string         `json:"amount"`
	Currency             sql.NullString `json:"currency"`
	PaymentMethod        sql.NullString `json:"payment_method"`
	PaymentGateway       sql.NullString `json:"payment_gateway"`
	GatewayTransactionID sql.NullString `json:"gateway_transaction_id"`
	Status               string         `json:"status"`
	TicketUrl            sql.NullString `json:"ticket_url"`
	InitiatedAt          sql.NullTime   `json:"initiated_at"`
	CompletedAt          sql.NullTime   `json:"completed_at"`
	FailedAt             sql.NullTime   `json:"failed_at"`
	ErrorMessage         sql.NullString `json:"error_message"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	BookingReference     string         `json:"booking_reference"`
	Quantity             int32          `json:"quantity"`
	EventID_2            uuid.UUID      `json:"event_id_2"`
}

func (q *Queries) GetUserPaymentHistory(ctx context.Context, db DBTX, arg GetUserPaymentHistoryParams) ([]GetUserPaymentHistoryRow, error) {
	rows, err := db.QueryContext(ctx, getUserPaymentHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPaymentHistoryRow{}
	for rows.Next() {
		var i GetUserPaymentHistoryRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentGateway,
			&i.GatewayTransactionID,
			&i.Status,
			&i.TicketUrl,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BookingReference,
			&i.Quantity,
			&i.EventID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPayments = `-- name: GetUserPayments :many
SELECT payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at FROM payments 
WHERE user_id = $1 AND status = 'completed'
ORDER BY completed_at DESC 
LIMIT $2 OFFSET $3
`

type GetUserPaymentsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetUserPayments(ctx context.Context, db DBTX, arg GetUserPaymentsParams) ([]Payment, error) {
	rows, err := db.QueryContext(ctx, getUserPayments, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.PaymentID,
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentGateway,
			&i.GatewayTransactionID,
			&i.Status,
			&i.TicketUrl,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments 
SET status = $2, updated_at = CURRENT_TIMESTAMP,
    completed_at = CASE WHEN $2 = 'completed' THEN CURRENT_TIMESTAMP ELSE completed_at END,
    failed_at = CASE WHEN $2 = 'failed' THEN CURRENT_TIMESTAMP ELSE failed_at END,
    error_message = $3
WHERE payment_id = $1 
RETURNING payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	PaymentID    uuid.UUID      `json:"payment_id"`
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, db DBTX, arg UpdatePaymentStatusParams) (Payment, error) {
	row := db.QueryRowContext(ctx, updatePaymentStatus, arg.PaymentID, arg.Status, arg.ErrorMessage)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentTicketURL = `-- name: UpdatePaymentTicketURL :one
UPDATE payments 
SET ticket_url = $2, updated_at = CURRENT_TIMESTAMP
WHERE payment_id = $1 
RETURNING payment_id, booking_id, user_id, event_id, amount, currency, payment_method, payment_gateway, gateway_transaction_id, status, ticket_url, initiated_at, completed_at, failed_at, error_message, created_at, updated_at
`

type UpdatePaymentTicketURLParams struct {
	PaymentID uuid.UUID      `json:"payment_id"`
	TicketUrl sql.NullString `json:"ticket_url"`
}

func (q *Queries) UpdatePaymentTicketURL(ctx context.Context, db DBTX, arg UpdatePaymentTicketURLParams) (Payment, error) {
	row := db.QueryRowContext(ctx, updatePaymentTicketURL, arg.PaymentID, arg.TicketUrl)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.TicketUrl,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
