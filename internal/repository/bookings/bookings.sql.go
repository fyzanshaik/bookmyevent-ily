// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings.sql

package bookings

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
    user_id, event_id, booking_reference, quantity, total_amount, 
    status, payment_status, idempotency_key, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at
`

type CreateBookingParams struct {
	UserID           uuid.UUID      `json:"user_id"`
	EventID          uuid.UUID      `json:"event_id"`
	BookingReference string         `json:"booking_reference"`
	Quantity         int32          `json:"quantity"`
	TotalAmount      string         `json:"total_amount"`
	Status           string         `json:"status"`
	PaymentStatus    string         `json:"payment_status"`
	IdempotencyKey   sql.NullString `json:"idempotency_key"`
	ExpiresAt        sql.NullTime   `json:"expires_at"`
}

func (q *Queries) CreateBooking(ctx context.Context, db DBTX, arg CreateBookingParams) (Booking, error) {
	row := db.QueryRowContext(ctx, createBooking,
		arg.UserID,
		arg.EventID,
		arg.BookingReference,
		arg.Quantity,
		arg.TotalAmount,
		arg.Status,
		arg.PaymentStatus,
		arg.IdempotencyKey,
		arg.ExpiresAt,
	)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBooking = `-- name: DeleteBooking :exec
DELETE FROM bookings WHERE booking_id = $1
`

func (q *Queries) DeleteBooking(ctx context.Context, db DBTX, bookingID uuid.UUID) error {
	_, err := db.ExecContext(ctx, deleteBooking, bookingID)
	return err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings WHERE booking_id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, db DBTX, bookingID uuid.UUID) (Booking, error) {
	row := db.QueryRowContext(ctx, getBookingByID, bookingID)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingByIdempotencyKey = `-- name: GetBookingByIdempotencyKey :one
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings WHERE idempotency_key = $1
`

func (q *Queries) GetBookingByIdempotencyKey(ctx context.Context, db DBTX, idempotencyKey sql.NullString) (Booking, error) {
	row := db.QueryRowContext(ctx, getBookingByIdempotencyKey, idempotencyKey)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingByReference = `-- name: GetBookingByReference :one
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings WHERE booking_reference = $1
`

func (q *Queries) GetBookingByReference(ctx context.Context, db DBTX, bookingReference string) (Booking, error) {
	row := db.QueryRowContext(ctx, getBookingByReference, bookingReference)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingWithPayment = `-- name: GetBookingWithPayment :one
SELECT 
    b.booking_id, b.user_id, b.event_id, b.booking_reference, b.quantity, b.total_amount, b.status, b.payment_status, b.idempotency_key, b.booked_at, b.expires_at, b.confirmed_at, b.cancelled_at, b.created_at, b.updated_at,
    p.payment_id,
    p.amount as payment_amount,
    p.gateway_transaction_id,
    p.payment_method,
    p.ticket_url,
    p.status as payment_status,
    p.completed_at as payment_completed_at
FROM bookings b
LEFT JOIN payments p ON b.booking_id = p.booking_id
WHERE b.booking_id = $1
`

type GetBookingWithPaymentRow struct {
	BookingID            uuid.UUID      `json:"booking_id"`
	UserID               uuid.UUID      `json:"user_id"`
	EventID              uuid.UUID      `json:"event_id"`
	BookingReference     string         `json:"booking_reference"`
	Quantity             int32          `json:"quantity"`
	TotalAmount          string         `json:"total_amount"`
	Status               string         `json:"status"`
	PaymentStatus        string         `json:"payment_status"`
	IdempotencyKey       sql.NullString `json:"idempotency_key"`
	BookedAt             sql.NullTime   `json:"booked_at"`
	ExpiresAt            sql.NullTime   `json:"expires_at"`
	ConfirmedAt          sql.NullTime   `json:"confirmed_at"`
	CancelledAt          sql.NullTime   `json:"cancelled_at"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	PaymentID            uuid.NullUUID  `json:"payment_id"`
	PaymentAmount        sql.NullString `json:"payment_amount"`
	GatewayTransactionID sql.NullString `json:"gateway_transaction_id"`
	PaymentMethod        sql.NullString `json:"payment_method"`
	TicketUrl            sql.NullString `json:"ticket_url"`
	PaymentStatus_2      sql.NullString `json:"payment_status_2"`
	PaymentCompletedAt   sql.NullTime   `json:"payment_completed_at"`
}

func (q *Queries) GetBookingWithPayment(ctx context.Context, db DBTX, bookingID uuid.UUID) (GetBookingWithPaymentRow, error) {
	row := db.QueryRowContext(ctx, getBookingWithPayment, bookingID)
	var i GetBookingWithPaymentRow
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentID,
		&i.PaymentAmount,
		&i.GatewayTransactionID,
		&i.PaymentMethod,
		&i.TicketUrl,
		&i.PaymentStatus_2,
		&i.PaymentCompletedAt,
	)
	return i, err
}

const getBookingsForCleanup = `-- name: GetBookingsForCleanup :many
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings 
WHERE status = 'pending' AND expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) GetBookingsForCleanup(ctx context.Context, db DBTX) ([]Booking, error) {
	rows, err := db.QueryContext(ctx, getBookingsForCleanup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.BookingReference,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.IdempotencyKey,
			&i.BookedAt,
			&i.ExpiresAt,
			&i.ConfirmedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventBookings = `-- name: GetEventBookings :many
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings 
WHERE event_id = $1 AND status = $2
ORDER BY created_at DESC 
LIMIT $3 OFFSET $4
`

type GetEventBookingsParams struct {
	EventID uuid.UUID `json:"event_id"`
	Status  string    `json:"status"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) GetEventBookings(ctx context.Context, db DBTX, arg GetEventBookingsParams) ([]Booking, error) {
	rows, err := db.QueryContext(ctx, getEventBookings,
		arg.EventID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.BookingReference,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.IdempotencyKey,
			&i.BookedAt,
			&i.ExpiresAt,
			&i.ConfirmedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredBookings = `-- name: GetExpiredBookings :many
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings 
WHERE status = 'pending' AND expires_at < CURRENT_TIMESTAMP
LIMIT $1
`

func (q *Queries) GetExpiredBookings(ctx context.Context, db DBTX, limit int32) ([]Booking, error) {
	rows, err := db.QueryContext(ctx, getExpiredBookings, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.BookingReference,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.IdempotencyKey,
			&i.BookedAt,
			&i.ExpiresAt,
			&i.ConfirmedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingBookings = `-- name: GetPendingBookings :many
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings 
WHERE status = 'pending'
LIMIT $1
`

func (q *Queries) GetPendingBookings(ctx context.Context, db DBTX, limit int32) ([]Booking, error) {
	rows, err := db.QueryContext(ctx, getPendingBookings, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.BookingReference,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.IdempotencyKey,
			&i.BookedAt,
			&i.ExpiresAt,
			&i.ConfirmedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookings = `-- name: GetUserBookings :many
SELECT booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at FROM bookings 
WHERE user_id = $1 
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetUserBookingsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetUserBookings(ctx context.Context, db DBTX, arg GetUserBookingsParams) ([]Booking, error) {
	rows, err := db.QueryContext(ctx, getUserBookings, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserID,
			&i.EventID,
			&i.BookingReference,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.IdempotencyKey,
			&i.BookedAt,
			&i.ExpiresAt,
			&i.ConfirmedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookingsCount = `-- name: GetUserBookingsCount :one
SELECT COUNT(*) FROM bookings WHERE user_id = $1
`

func (q *Queries) GetUserBookingsCount(ctx context.Context, db DBTX, userID uuid.UUID) (int64, error) {
	row := db.QueryRowContext(ctx, getUserBookingsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateBookingPaymentStatus = `-- name: UpdateBookingPaymentStatus :one
UPDATE bookings 
SET payment_status = $2, updated_at = CURRENT_TIMESTAMP
WHERE booking_id = $1 
RETURNING booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at
`

type UpdateBookingPaymentStatusParams struct {
	BookingID     uuid.UUID `json:"booking_id"`
	PaymentStatus string    `json:"payment_status"`
}

func (q *Queries) UpdateBookingPaymentStatus(ctx context.Context, db DBTX, arg UpdateBookingPaymentStatusParams) (Booking, error) {
	row := db.QueryRowContext(ctx, updateBookingPaymentStatus, arg.BookingID, arg.PaymentStatus)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :one
UPDATE bookings 
SET status = $1::VARCHAR, updated_at = CURRENT_TIMESTAMP,
    confirmed_at = CASE WHEN $1::VARCHAR = 'confirmed' THEN CURRENT_TIMESTAMP ELSE confirmed_at END,
    cancelled_at = CASE WHEN $1::VARCHAR = 'cancelled' THEN CURRENT_TIMESTAMP ELSE cancelled_at END
WHERE booking_id = $2 
RETURNING booking_id, user_id, event_id, booking_reference, quantity, total_amount, status, payment_status, idempotency_key, booked_at, expires_at, confirmed_at, cancelled_at, created_at, updated_at
`

type UpdateBookingStatusParams struct {
	Status    string    `json:"status"`
	BookingID uuid.UUID `json:"booking_id"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, db DBTX, arg UpdateBookingStatusParams) (Booking, error) {
	row := db.QueryRowContext(ctx, updateBookingStatus, arg.Status, arg.BookingID)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserID,
		&i.EventID,
		&i.BookingReference,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.IdempotencyKey,
		&i.BookedAt,
		&i.ExpiresAt,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
