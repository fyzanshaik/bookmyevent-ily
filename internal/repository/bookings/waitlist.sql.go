// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: waitlist.sql

package bookings

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getEventWaitlist = `-- name: GetEventWaitlist :many
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist
WHERE event_id = $1 AND status = 'waiting'
ORDER BY position ASC
LIMIT $2
`

type GetEventWaitlistParams struct {
	EventID uuid.UUID `json:"event_id"`
	Limit   int32     `json:"limit"`
}

func (q *Queries) GetEventWaitlist(ctx context.Context, db DBTX, arg GetEventWaitlistParams) ([]Waitlist, error) {
	rows, err := db.QueryContext(ctx, getEventWaitlist, arg.EventID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.WaitlistID,
			&i.EventID,
			&i.UserID,
			&i.Position,
			&i.QuantityRequested,
			&i.Status,
			&i.JoinedAt,
			&i.OfferedAt,
			&i.ExpiresAt,
			&i.ConvertedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredWaitlistOffers = `-- name: GetExpiredWaitlistOffers :many
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist
WHERE status = 'offered'
    AND expires_at IS NOT NULL
    AND expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) GetExpiredWaitlistOffers(ctx context.Context, db DBTX) ([]Waitlist, error) {
	rows, err := db.QueryContext(ctx, getExpiredWaitlistOffers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.WaitlistID,
			&i.EventID,
			&i.UserID,
			&i.Position,
			&i.QuantityRequested,
			&i.Status,
			&i.JoinedAt,
			&i.OfferedAt,
			&i.ExpiresAt,
			&i.ConvertedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextWaitlistEntries = `-- name: GetNextWaitlistEntries :many
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist
WHERE event_id = $1 AND status = 'waiting'
ORDER BY position ASC
LIMIT $2
`

type GetNextWaitlistEntriesParams struct {
	EventID uuid.UUID `json:"event_id"`
	Limit   int32     `json:"limit"`
}

func (q *Queries) GetNextWaitlistEntries(ctx context.Context, db DBTX, arg GetNextWaitlistEntriesParams) ([]Waitlist, error) {
	rows, err := db.QueryContext(ctx, getNextWaitlistEntries, arg.EventID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.WaitlistID,
			&i.EventID,
			&i.UserID,
			&i.Position,
			&i.QuantityRequested,
			&i.Status,
			&i.JoinedAt,
			&i.OfferedAt,
			&i.ExpiresAt,
			&i.ConvertedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferedWaitlistEntries = `-- name: GetOfferedWaitlistEntries :many
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist
WHERE status = 'offered' AND expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) GetOfferedWaitlistEntries(ctx context.Context, db DBTX) ([]Waitlist, error) {
	rows, err := db.QueryContext(ctx, getOfferedWaitlistEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Waitlist{}
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.WaitlistID,
			&i.EventID,
			&i.UserID,
			&i.Position,
			&i.QuantityRequested,
			&i.Status,
			&i.JoinedAt,
			&i.OfferedAt,
			&i.ExpiresAt,
			&i.ConvertedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWaitlistEntry = `-- name: GetUserWaitlistEntry :one
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist WHERE user_id = $1 AND event_id = $2
`

type GetUserWaitlistEntryParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) GetUserWaitlistEntry(ctx context.Context, db DBTX, arg GetUserWaitlistEntryParams) (Waitlist, error) {
	row := db.QueryRowContext(ctx, getUserWaitlistEntry, arg.UserID, arg.EventID)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistEntry = `-- name: GetWaitlistEntry :one
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist WHERE waitlist_id = $1
`

func (q *Queries) GetWaitlistEntry(ctx context.Context, db DBTX, waitlistID uuid.UUID) (Waitlist, error) {
	row := db.QueryRowContext(ctx, getWaitlistEntry, waitlistID)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistEntryByUserAndEvent = `-- name: GetWaitlistEntryByUserAndEvent :one
SELECT waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at FROM waitlist
WHERE user_id = $1 AND event_id = $2
`

type GetWaitlistEntryByUserAndEventParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) GetWaitlistEntryByUserAndEvent(ctx context.Context, db DBTX, arg GetWaitlistEntryByUserAndEventParams) (Waitlist, error) {
	row := db.QueryRowContext(ctx, getWaitlistEntryByUserAndEvent, arg.UserID, arg.EventID)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistPosition = `-- name: GetWaitlistPosition :one
SELECT position, status FROM waitlist
WHERE user_id = $1 AND event_id = $2
`

type GetWaitlistPositionParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

type GetWaitlistPositionRow struct {
	Position int32          `json:"position"`
	Status   sql.NullString `json:"status"`
}

func (q *Queries) GetWaitlistPosition(ctx context.Context, db DBTX, arg GetWaitlistPositionParams) (GetWaitlistPositionRow, error) {
	row := db.QueryRowContext(ctx, getWaitlistPosition, arg.UserID, arg.EventID)
	var i GetWaitlistPositionRow
	err := row.Scan(&i.Position, &i.Status)
	return i, err
}

const getWaitlistStats = `-- name: GetWaitlistStats :one
SELECT
    COUNT(*) as total_waiting,
    COALESCE(MIN(position), 0) as first_position,
    COALESCE(MAX(position), 0) as last_position,
    COALESCE(AVG(quantity_requested), 0.0) as avg_quantity_requested
FROM waitlist
WHERE event_id = $1 AND status = 'waiting'
`

type GetWaitlistStatsRow struct {
	TotalWaiting         int64       `json:"total_waiting"`
	FirstPosition        interface{} `json:"first_position"`
	LastPosition         interface{} `json:"last_position"`
	AvgQuantityRequested interface{} `json:"avg_quantity_requested"`
}

func (q *Queries) GetWaitlistStats(ctx context.Context, db DBTX, eventID uuid.UUID) (GetWaitlistStatsRow, error) {
	row := db.QueryRowContext(ctx, getWaitlistStats, eventID)
	var i GetWaitlistStatsRow
	err := row.Scan(
		&i.TotalWaiting,
		&i.FirstPosition,
		&i.LastPosition,
		&i.AvgQuantityRequested,
	)
	return i, err
}

const joinWaitlist = `-- name: JoinWaitlist :one
INSERT INTO waitlist (
    event_id, user_id, quantity_requested, position
) VALUES (
    $1, $2, $3,
    COALESCE((SELECT MAX(position) FROM waitlist WHERE event_id = $1 AND status = 'waiting'), 0) + 1
) RETURNING waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at
`

type JoinWaitlistParams struct {
	EventID           uuid.UUID `json:"event_id"`
	UserID            uuid.UUID `json:"user_id"`
	QuantityRequested int32     `json:"quantity_requested"`
}

func (q *Queries) JoinWaitlist(ctx context.Context, db DBTX, arg JoinWaitlistParams) (Waitlist, error) {
	row := db.QueryRowContext(ctx, joinWaitlist, arg.EventID, arg.UserID, arg.QuantityRequested)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const reassignWaitlistPosition = `-- name: ReassignWaitlistPosition :exec
UPDATE waitlist
SET position = $2, updated_at = CURRENT_TIMESTAMP
WHERE waitlist_id = $1
`

type ReassignWaitlistPositionParams struct {
	WaitlistID uuid.UUID `json:"waitlist_id"`
	Position   int32     `json:"position"`
}

func (q *Queries) ReassignWaitlistPosition(ctx context.Context, db DBTX, arg ReassignWaitlistPositionParams) error {
	_, err := db.ExecContext(ctx, reassignWaitlistPosition, arg.WaitlistID, arg.Position)
	return err
}

const removeFromWaitlist = `-- name: RemoveFromWaitlist :exec
DELETE FROM waitlist WHERE user_id = $1 AND event_id = $2
`

type RemoveFromWaitlistParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) RemoveFromWaitlist(ctx context.Context, db DBTX, arg RemoveFromWaitlistParams) error {
	_, err := db.ExecContext(ctx, removeFromWaitlist, arg.UserID, arg.EventID)
	return err
}

const reorderWaitlistAfterRemoval = `-- name: ReorderWaitlistAfterRemoval :exec
UPDATE waitlist
SET position = position - 1, updated_at = CURRENT_TIMESTAMP
WHERE event_id = $1 AND position > $2 AND status = 'waiting'
`

type ReorderWaitlistAfterRemovalParams struct {
	EventID  uuid.UUID `json:"event_id"`
	Position int32     `json:"position"`
}

func (q *Queries) ReorderWaitlistAfterRemoval(ctx context.Context, db DBTX, arg ReorderWaitlistAfterRemovalParams) error {
	_, err := db.ExecContext(ctx, reorderWaitlistAfterRemoval, arg.EventID, arg.Position)
	return err
}

const setWaitlistOffered = `-- name: SetWaitlistOffered :one
UPDATE waitlist
SET status = 'offered', 
    offered_at = CURRENT_TIMESTAMP,
    expires_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE waitlist_id = $1
RETURNING waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at
`

type SetWaitlistOfferedParams struct {
	WaitlistID uuid.UUID    `json:"waitlist_id"`
	ExpiresAt  sql.NullTime `json:"expires_at"`
}

func (q *Queries) SetWaitlistOffered(ctx context.Context, db DBTX, arg SetWaitlistOfferedParams) (Waitlist, error) {
	row := db.QueryRowContext(ctx, setWaitlistOffered, arg.WaitlistID, arg.ExpiresAt)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setWaitlistWaiting = `-- name: SetWaitlistWaiting :one
UPDATE waitlist
SET status = 'waiting',
    expires_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE waitlist_id = $1
RETURNING waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at
`

func (q *Queries) SetWaitlistWaiting(ctx context.Context, db DBTX, waitlistID uuid.UUID) (Waitlist, error) {
	row := db.QueryRowContext(ctx, setWaitlistWaiting, waitlistID)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWaitlistStatus = `-- name: UpdateWaitlistStatus :one
UPDATE waitlist
SET status = COALESCE($2, status),
    updated_at = CURRENT_TIMESTAMP,
    offered_at = CASE WHEN $2::text = 'offered' THEN CURRENT_TIMESTAMP ELSE offered_at END,
    converted_at = CASE WHEN $2::text = 'converted' THEN CURRENT_TIMESTAMP ELSE converted_at END,
    expires_at = $3
WHERE waitlist_id = $1
RETURNING waitlist_id, event_id, user_id, position, quantity_requested, status, joined_at, offered_at, expires_at, converted_at, created_at, updated_at
`

type UpdateWaitlistStatusParams struct {
	WaitlistID uuid.UUID      `json:"waitlist_id"`
	Status     sql.NullString `json:"status"`
	ExpiresAt  sql.NullTime   `json:"expires_at"`
}

func (q *Queries) UpdateWaitlistStatus(ctx context.Context, db DBTX, arg UpdateWaitlistStatusParams) (Waitlist, error) {
	row := db.QueryRowContext(ctx, updateWaitlistStatus, arg.WaitlistID, arg.Status, arg.ExpiresAt)
	var i Waitlist
	err := row.Scan(
		&i.WaitlistID,
		&i.EventID,
		&i.UserID,
		&i.Position,
		&i.QuantityRequested,
		&i.Status,
		&i.JoinedAt,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.ConvertedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
