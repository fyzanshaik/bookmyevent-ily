// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: venues.sql

package events

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const countVenues = `-- name: CountVenues :one
SELECT COUNT(*) FROM venues
WHERE ($1::text IS NULL OR city ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR state ILIKE '%' || $2 || '%')
`

type CountVenuesParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

// COUNT VENUES (for pagination)
//
//	SELECT COUNT(*) FROM venues
//	WHERE ($1::text IS NULL OR city ILIKE '%' || $1 || '%')
//	  AND ($2::text IS NULL OR state ILIKE '%' || $2 || '%')
func (q *Queries) CountVenues(ctx context.Context, arg CountVenuesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVenues, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVenue = `-- name: CreateVenue :one

INSERT INTO venues (
    name, address, city, state, country, postal_code, capacity, layout_config
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at
`

type CreateVenueParams struct {
	Name         string                `json:"name"`
	Address      string                `json:"address"`
	City         string                `json:"city"`
	State        sql.NullString        `json:"state"`
	Country      string                `json:"country"`
	PostalCode   sql.NullString        `json:"postal_code"`
	Capacity     int32                 `json:"capacity"`
	LayoutConfig pqtype.NullRawMessage `json:"layout_config"`
}

// Venue Management Queries
// CREATE VENUE
//
//	INSERT INTO venues (
//	    name, address, city, state, country, postal_code, capacity, layout_config
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8
//	)
//	RETURNING venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at
func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (Venue, error) {
	row := q.db.QueryRowContext(ctx, createVenue,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.Capacity,
		arg.LayoutConfig,
	)
	var i Venue
	err := row.Scan(
		&i.VenueID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.Capacity,
		&i.LayoutConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVenue = `-- name: DeleteVenue :exec
DELETE FROM venues WHERE venue_id = $1
`

// DELETE VENUE
//
//	DELETE FROM venues WHERE venue_id = $1
func (q *Queries) DeleteVenue(ctx context.Context, venueID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteVenue, venueID)
	return err
}

const getVenueByID = `-- name: GetVenueByID :one
SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues WHERE venue_id = $1
`

// GET VENUE BY ID
//
//	SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues WHERE venue_id = $1
func (q *Queries) GetVenueByID(ctx context.Context, venueID uuid.UUID) (Venue, error) {
	row := q.db.QueryRowContext(ctx, getVenueByID, venueID)
	var i Venue
	err := row.Scan(
		&i.VenueID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.Capacity,
		&i.LayoutConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVenuesByCity = `-- name: GetVenuesByCity :many
SELECT venue_id, name, capacity, address FROM venues 
WHERE city = $1 
ORDER BY name
`

type GetVenuesByCityRow struct {
	VenueID  uuid.UUID `json:"venue_id"`
	Name     string    `json:"name"`
	Capacity int32     `json:"capacity"`
	Address  string    `json:"address"`
}

// GET VENUES BY CITY (for event creation dropdown)
//
//	SELECT venue_id, name, capacity, address FROM venues
//	WHERE city = $1
//	ORDER BY name
func (q *Queries) GetVenuesByCity(ctx context.Context, city string) ([]GetVenuesByCityRow, error) {
	rows, err := q.db.QueryContext(ctx, getVenuesByCity, city)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVenuesByCityRow{}
	for rows.Next() {
		var i GetVenuesByCityRow
		if err := rows.Scan(
			&i.VenueID,
			&i.Name,
			&i.Capacity,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenues = `-- name: ListVenues :many
SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues
WHERE ($3::text IS NULL OR city ILIKE '%' || $3 || '%')
  AND ($4::text IS NULL OR state ILIKE '%' || $4 || '%')
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListVenuesParams struct {
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
}

// LIST VENUES
//
//	SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues
//	WHERE ($3::text IS NULL OR city ILIKE '%' || $3 || '%')
//	  AND ($4::text IS NULL OR state ILIKE '%' || $4 || '%')
//	ORDER BY name
//	LIMIT $1 OFFSET $2
func (q *Queries) ListVenues(ctx context.Context, arg ListVenuesParams) ([]Venue, error) {
	rows, err := q.db.QueryContext(ctx, listVenues,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Venue{}
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.VenueID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.Capacity,
			&i.LayoutConfig,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVenues = `-- name: SearchVenues :many
SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues
WHERE name ILIKE '%' || $1 || '%' 
   OR city ILIKE '%' || $1 || '%'
   OR address ILIKE '%' || $1 || '%'
ORDER BY 
    CASE WHEN name ILIKE $1 || '%' THEN 1 ELSE 2 END,
    name
LIMIT 10
`

// SEARCH VENUES
//
//	SELECT venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at FROM venues
//	WHERE name ILIKE '%' || $1 || '%'
//	   OR city ILIKE '%' || $1 || '%'
//	   OR address ILIKE '%' || $1 || '%'
//	ORDER BY
//	    CASE WHEN name ILIKE $1 || '%' THEN 1 ELSE 2 END,
//	    name
//	LIMIT 10
func (q *Queries) SearchVenues(ctx context.Context, dollar_1 sql.NullString) ([]Venue, error) {
	rows, err := q.db.QueryContext(ctx, searchVenues, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Venue{}
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.VenueID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.Capacity,
			&i.LayoutConfig,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVenue = `-- name: UpdateVenue :one
UPDATE venues 
SET name = COALESCE($2, name),
    address = COALESCE($3, address),
    city = COALESCE($4, city),
    state = COALESCE($5, state),
    country = COALESCE($6, country),
    postal_code = COALESCE($7, postal_code),
    capacity = COALESCE($8, capacity),
    layout_config = COALESCE($9, layout_config),
    updated_at = CURRENT_TIMESTAMP
WHERE venue_id = $1
RETURNING venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at
`

type UpdateVenueParams struct {
	VenueID      uuid.UUID             `json:"venue_id"`
	Name         string                `json:"name"`
	Address      string                `json:"address"`
	City         string                `json:"city"`
	State        sql.NullString        `json:"state"`
	Country      string                `json:"country"`
	PostalCode   sql.NullString        `json:"postal_code"`
	Capacity     int32                 `json:"capacity"`
	LayoutConfig pqtype.NullRawMessage `json:"layout_config"`
}

// UPDATE VENUE
//
//	UPDATE venues
//	SET name = COALESCE($2, name),
//	    address = COALESCE($3, address),
//	    city = COALESCE($4, city),
//	    state = COALESCE($5, state),
//	    country = COALESCE($6, country),
//	    postal_code = COALESCE($7, postal_code),
//	    capacity = COALESCE($8, capacity),
//	    layout_config = COALESCE($9, layout_config),
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE venue_id = $1
//	RETURNING venue_id, name, address, city, state, country, postal_code, capacity, layout_config, created_at, updated_at
func (q *Queries) UpdateVenue(ctx context.Context, arg UpdateVenueParams) (Venue, error) {
	row := q.db.QueryRowContext(ctx, updateVenue,
		arg.VenueID,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.Capacity,
		arg.LayoutConfig,
	)
	var i Venue
	err := row.Scan(
		&i.VenueID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.Capacity,
		&i.LayoutConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
