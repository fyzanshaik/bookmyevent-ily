// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package events

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkEventOwnership = `-- name: CheckEventOwnership :one
SELECT event_id, created_by, status, version
FROM events
WHERE event_id = $1 AND created_by = $2
`

type CheckEventOwnershipParams struct {
	EventID   uuid.UUID `json:"event_id"`
	CreatedBy uuid.UUID `json:"created_by"`
}

type CheckEventOwnershipRow struct {
	EventID   uuid.UUID      `json:"event_id"`
	CreatedBy uuid.UUID      `json:"created_by"`
	Status    sql.NullString `json:"status"`
	Version   int32          `json:"version"`
}

// CheckEventOwnership
//
//	SELECT event_id, created_by, status, version
//	FROM events
//	WHERE event_id = $1 AND created_by = $2
func (q *Queries) CheckEventOwnership(ctx context.Context, arg CheckEventOwnershipParams) (CheckEventOwnershipRow, error) {
	row := q.db.QueryRowContext(ctx, checkEventOwnership, arg.EventID, arg.CreatedBy)
	var i CheckEventOwnershipRow
	err := row.Scan(
		&i.EventID,
		&i.CreatedBy,
		&i.Status,
		&i.Version,
	)
	return i, err
}

const countPublishedEvents = `-- name: CountPublishedEvents :one
SELECT COUNT(*)
FROM events e
JOIN venues v ON e.venue_id = v.venue_id
WHERE e.status = 'published'
  AND e.start_datetime > CURRENT_TIMESTAMP
  AND ($1::text = '' OR e.event_type = $1)
  AND ($2::text = '' OR v.city ILIKE '%' || $2 || '%')
  AND ($3::timestamp = '0001-01-01'::timestamp OR e.start_datetime >= $3)
  AND ($4::timestamp = '0001-01-01'::timestamp OR e.start_datetime <= $4)
`

type CountPublishedEventsParams struct {
	Column1 string    `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

// CountPublishedEvents
//
//	SELECT COUNT(*)
//	FROM events e
//	JOIN venues v ON e.venue_id = v.venue_id
//	WHERE e.status = 'published'
//	  AND e.start_datetime > CURRENT_TIMESTAMP
//	  AND ($1::text = '' OR e.event_type = $1)
//	  AND ($2::text = '' OR v.city ILIKE '%' || $2 || '%')
//	  AND ($3::timestamp = '0001-01-01'::timestamp OR e.start_datetime >= $3)
//	  AND ($4::timestamp = '0001-01-01'::timestamp OR e.start_datetime <= $4)
func (q *Queries) CountPublishedEvents(ctx context.Context, arg CountPublishedEventsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    name, description, venue_id, event_type, start_datetime, end_datetime,
    total_capacity, available_seats, base_price, max_tickets_per_booking,
    status, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING event_id, name, description, venue_id, event_type, start_datetime, end_datetime, total_capacity, available_seats, base_price, max_tickets_per_booking, status, version, created_by, created_at, updated_at
`

type CreateEventParams struct {
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	VenueID              uuid.UUID      `json:"venue_id"`
	EventType            string         `json:"event_type"`
	StartDatetime        time.Time      `json:"start_datetime"`
	EndDatetime          time.Time      `json:"end_datetime"`
	TotalCapacity        int32          `json:"total_capacity"`
	AvailableSeats       int32          `json:"available_seats"`
	BasePrice            string         `json:"base_price"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	CreatedBy            uuid.UUID      `json:"created_by"`
}

// CreateEvent
//
//	INSERT INTO events (
//	    name, description, venue_id, event_type, start_datetime, end_datetime,
//	    total_capacity, available_seats, base_price, max_tickets_per_booking,
//	    status, created_by
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
//	)
//	RETURNING event_id, name, description, venue_id, event_type, start_datetime, end_datetime, total_capacity, available_seats, base_price, max_tickets_per_booking, status, version, created_by, created_at, updated_at
func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Name,
		arg.Description,
		arg.VenueID,
		arg.EventType,
		arg.StartDatetime,
		arg.EndDatetime,
		arg.TotalCapacity,
		arg.AvailableSeats,
		arg.BasePrice,
		arg.MaxTicketsPerBooking,
		arg.Status,
		arg.CreatedBy,
	)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.VenueID,
		&i.EventType,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.TotalCapacity,
		&i.AvailableSeats,
		&i.BasePrice,
		&i.MaxTicketsPerBooking,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
UPDATE events
SET status = 'cancelled',
    updated_at = CURRENT_TIMESTAMP,
    version = version + 1
WHERE event_id = $1
  AND version = $2
`

type DeleteEventParams struct {
	EventID uuid.UUID `json:"event_id"`
	Version int32     `json:"version"`
}

// DeleteEvent
//
//	UPDATE events
//	SET status = 'cancelled',
//	    updated_at = CURRENT_TIMESTAMP,
//	    version = version + 1
//	WHERE event_id = $1
//	  AND version = $2
func (q *Queries) DeleteEvent(ctx context.Context, arg DeleteEventParams) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, arg.EventID, arg.Version)
	return err
}

const getEventAnalytics = `-- name: GetEventAnalytics :one
SELECT
    e.event_id,
    e.name,
    e.total_capacity,
    e.available_seats,
    (e.total_capacity - e.available_seats) as tickets_sold,
    ROUND(((e.total_capacity - e.available_seats)::decimal / e.total_capacity::decimal) * 100, 2) as capacity_utilization,
    e.base_price,
    ROUND((e.total_capacity - e.available_seats) * e.base_price::decimal, 2) as estimated_revenue
FROM events e
WHERE e.event_id = $1
`

type GetEventAnalyticsRow struct {
	EventID             uuid.UUID `json:"event_id"`
	Name                string    `json:"name"`
	TotalCapacity       int32     `json:"total_capacity"`
	AvailableSeats      int32     `json:"available_seats"`
	TicketsSold         int32     `json:"tickets_sold"`
	CapacityUtilization string    `json:"capacity_utilization"`
	BasePrice           string    `json:"base_price"`
	EstimatedRevenue    string    `json:"estimated_revenue"`
}

// GetEventAnalytics
//
//	SELECT
//	    e.event_id,
//	    e.name,
//	    e.total_capacity,
//	    e.available_seats,
//	    (e.total_capacity - e.available_seats) as tickets_sold,
//	    ROUND(((e.total_capacity - e.available_seats)::decimal / e.total_capacity::decimal) * 100, 2) as capacity_utilization,
//	    e.base_price,
//	    ROUND((e.total_capacity - e.available_seats) * e.base_price::decimal, 2) as estimated_revenue
//	FROM events e
//	WHERE e.event_id = $1
func (q *Queries) GetEventAnalytics(ctx context.Context, eventID uuid.UUID) (GetEventAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getEventAnalytics, eventID)
	var i GetEventAnalyticsRow
	err := row.Scan(
		&i.EventID,
		&i.Name,
		&i.TotalCapacity,
		&i.AvailableSeats,
		&i.TicketsSold,
		&i.CapacityUtilization,
		&i.BasePrice,
		&i.EstimatedRevenue,
	)
	return i, err
}

const getEventByID = `-- name: GetEventByID :one
SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.address, v.city, v.state, v.country
FROM events e
JOIN venues v ON e.venue_id = v.venue_id
WHERE e.event_id = $1
`

type GetEventByIDRow struct {
	EventID              uuid.UUID      `json:"event_id"`
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	VenueID              uuid.UUID      `json:"venue_id"`
	EventType            string         `json:"event_type"`
	StartDatetime        time.Time      `json:"start_datetime"`
	EndDatetime          time.Time      `json:"end_datetime"`
	TotalCapacity        int32          `json:"total_capacity"`
	AvailableSeats       int32          `json:"available_seats"`
	BasePrice            string         `json:"base_price"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	Version              int32          `json:"version"`
	CreatedBy            uuid.UUID      `json:"created_by"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	VenueName            string         `json:"venue_name"`
	Address              string         `json:"address"`
	City                 string         `json:"city"`
	State                sql.NullString `json:"state"`
	Country              string         `json:"country"`
}

// GetEventByID
//
//	SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.address, v.city, v.state, v.country
//	FROM events e
//	JOIN venues v ON e.venue_id = v.venue_id
//	WHERE e.event_id = $1
func (q *Queries) GetEventByID(ctx context.Context, eventID uuid.UUID) (GetEventByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getEventByID, eventID)
	var i GetEventByIDRow
	err := row.Scan(
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.VenueID,
		&i.EventType,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.TotalCapacity,
		&i.AvailableSeats,
		&i.BasePrice,
		&i.MaxTicketsPerBooking,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VenueName,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
	)
	return i, err
}

const getEventForBooking = `-- name: GetEventForBooking :one
SELECT event_id, available_seats, total_capacity, max_tickets_per_booking,
       status, version, base_price, name
FROM events
WHERE event_id = $1
  AND (status = 'published' OR status = 'sold_out')
FOR UPDATE
`

type GetEventForBookingRow struct {
	EventID              uuid.UUID      `json:"event_id"`
	AvailableSeats       int32          `json:"available_seats"`
	TotalCapacity        int32          `json:"total_capacity"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	Version              int32          `json:"version"`
	BasePrice            string         `json:"base_price"`
	Name                 string         `json:"name"`
}

// GetEventForBooking
//
//	SELECT event_id, available_seats, total_capacity, max_tickets_per_booking,
//	       status, version, base_price, name
//	FROM events
//	WHERE event_id = $1
//	  AND (status = 'published' OR status = 'sold_out')
//	FOR UPDATE
func (q *Queries) GetEventForBooking(ctx context.Context, eventID uuid.UUID) (GetEventForBookingRow, error) {
	row := q.db.QueryRowContext(ctx, getEventForBooking, eventID)
	var i GetEventForBookingRow
	err := row.Scan(
		&i.EventID,
		&i.AvailableSeats,
		&i.TotalCapacity,
		&i.MaxTicketsPerBooking,
		&i.Status,
		&i.Version,
		&i.BasePrice,
		&i.Name,
	)
	return i, err
}

const listEventsByAdmin = `-- name: ListEventsByAdmin :many
SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.city
FROM events e
JOIN venues v ON e.venue_id = v.venue_id
WHERE e.created_by = $3
ORDER BY e.created_at DESC
LIMIT $1 OFFSET $2
`

type ListEventsByAdminParams struct {
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	CreatedBy uuid.UUID `json:"created_by"`
}

type ListEventsByAdminRow struct {
	EventID              uuid.UUID      `json:"event_id"`
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	VenueID              uuid.UUID      `json:"venue_id"`
	EventType            string         `json:"event_type"`
	StartDatetime        time.Time      `json:"start_datetime"`
	EndDatetime          time.Time      `json:"end_datetime"`
	TotalCapacity        int32          `json:"total_capacity"`
	AvailableSeats       int32          `json:"available_seats"`
	BasePrice            string         `json:"base_price"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	Version              int32          `json:"version"`
	CreatedBy            uuid.UUID      `json:"created_by"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	VenueName            string         `json:"venue_name"`
	City                 string         `json:"city"`
}

// ListEventsByAdmin
//
//	SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.city
//	FROM events e
//	JOIN venues v ON e.venue_id = v.venue_id
//	WHERE e.created_by = $3
//	ORDER BY e.created_at DESC
//	LIMIT $1 OFFSET $2
func (q *Queries) ListEventsByAdmin(ctx context.Context, arg ListEventsByAdminParams) ([]ListEventsByAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByAdmin, arg.Limit, arg.Offset, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByAdminRow{}
	for rows.Next() {
		var i ListEventsByAdminRow
		if err := rows.Scan(
			&i.EventID,
			&i.Name,
			&i.Description,
			&i.VenueID,
			&i.EventType,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.TotalCapacity,
			&i.AvailableSeats,
			&i.BasePrice,
			&i.MaxTicketsPerBooking,
			&i.Status,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VenueName,
			&i.City,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedEvents = `-- name: ListPublishedEvents :many
SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.city, v.state
FROM events e
JOIN venues v ON e.venue_id = v.venue_id
WHERE e.status = 'published'
  AND e.start_datetime > CURRENT_TIMESTAMP
  AND ($3::text = '' OR e.event_type = $3)
  AND ($4::text = '' OR v.city ILIKE '%' || $4 || '%')
  AND ($5::timestamp = '0001-01-01'::timestamp OR e.start_datetime >= $5)
  AND ($6::timestamp = '0001-01-01'::timestamp OR e.start_datetime <= $6)
ORDER BY e.start_datetime ASC
LIMIT $1 OFFSET $2
`

type ListPublishedEventsParams struct {
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Column6 time.Time `json:"column_6"`
}

type ListPublishedEventsRow struct {
	EventID              uuid.UUID      `json:"event_id"`
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	VenueID              uuid.UUID      `json:"venue_id"`
	EventType            string         `json:"event_type"`
	StartDatetime        time.Time      `json:"start_datetime"`
	EndDatetime          time.Time      `json:"end_datetime"`
	TotalCapacity        int32          `json:"total_capacity"`
	AvailableSeats       int32          `json:"available_seats"`
	BasePrice            string         `json:"base_price"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	Version              int32          `json:"version"`
	CreatedBy            uuid.UUID      `json:"created_by"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	VenueName            string         `json:"venue_name"`
	City                 string         `json:"city"`
	State                sql.NullString `json:"state"`
}

// ListPublishedEvents
//
//	SELECT e.event_id, e.name, e.description, e.venue_id, e.event_type, e.start_datetime, e.end_datetime, e.total_capacity, e.available_seats, e.base_price, e.max_tickets_per_booking, e.status, e.version, e.created_by, e.created_at, e.updated_at, v.name as venue_name, v.city, v.state
//	FROM events e
//	JOIN venues v ON e.venue_id = v.venue_id
//	WHERE e.status = 'published'
//	  AND e.start_datetime > CURRENT_TIMESTAMP
//	  AND ($3::text = '' OR e.event_type = $3)
//	  AND ($4::text = '' OR v.city ILIKE '%' || $4 || '%')
//	  AND ($5::timestamp = '0001-01-01'::timestamp OR e.start_datetime >= $5)
//	  AND ($6::timestamp = '0001-01-01'::timestamp OR e.start_datetime <= $6)
//	ORDER BY e.start_datetime ASC
//	LIMIT $1 OFFSET $2
func (q *Queries) ListPublishedEvents(ctx context.Context, arg ListPublishedEventsParams) ([]ListPublishedEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedEvents,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedEventsRow{}
	for rows.Next() {
		var i ListPublishedEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.Name,
			&i.Description,
			&i.VenueID,
			&i.EventType,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.TotalCapacity,
			&i.AvailableSeats,
			&i.BasePrice,
			&i.MaxTicketsPerBooking,
			&i.Status,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VenueName,
			&i.City,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnEventSeats = `-- name: ReturnEventSeats :one
UPDATE events
SET available_seats = available_seats + $2,
    version = version + 1,
    updated_at = CURRENT_TIMESTAMP,
    status = CASE
        WHEN status = 'sold_out' AND (available_seats + $2) > 0 THEN 'published'::text
        ELSE status
    END
WHERE event_id = $1
  AND version = $3
RETURNING event_id, available_seats, status, version
`

type ReturnEventSeatsParams struct {
	EventID        uuid.UUID `json:"event_id"`
	AvailableSeats int32     `json:"available_seats"`
	Version        int32     `json:"version"`
}

type ReturnEventSeatsRow struct {
	EventID        uuid.UUID      `json:"event_id"`
	AvailableSeats int32          `json:"available_seats"`
	Status         sql.NullString `json:"status"`
	Version        int32          `json:"version"`
}

// ReturnEventSeats
//
//	UPDATE events
//	SET available_seats = available_seats + $2,
//	    version = version + 1,
//	    updated_at = CURRENT_TIMESTAMP,
//	    status = CASE
//	        WHEN status = 'sold_out' AND (available_seats + $2) > 0 THEN 'published'::text
//	        ELSE status
//	    END
//	WHERE event_id = $1
//	  AND version = $3
//	RETURNING event_id, available_seats, status, version
func (q *Queries) ReturnEventSeats(ctx context.Context, arg ReturnEventSeatsParams) (ReturnEventSeatsRow, error) {
	row := q.db.QueryRowContext(ctx, returnEventSeats, arg.EventID, arg.AvailableSeats, arg.Version)
	var i ReturnEventSeatsRow
	err := row.Scan(
		&i.EventID,
		&i.AvailableSeats,
		&i.Status,
		&i.Version,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    venue_id = COALESCE($4, venue_id),
    event_type = COALESCE($5, event_type),
    start_datetime = COALESCE($6, start_datetime),
    end_datetime = COALESCE($7, end_datetime),
    total_capacity = COALESCE($8, total_capacity),
    available_seats = COALESCE($9, available_seats),
    base_price = COALESCE($10, base_price),
    max_tickets_per_booking = COALESCE($11, max_tickets_per_booking),
    status = COALESCE($12, status),
    updated_at = CURRENT_TIMESTAMP,
    version = version + 1
WHERE event_id = $1
  AND version = $13
RETURNING event_id, name, description, venue_id, event_type, start_datetime, end_datetime, total_capacity, available_seats, base_price, max_tickets_per_booking, status, version, created_by, created_at, updated_at
`

type UpdateEventParams struct {
	EventID              uuid.UUID      `json:"event_id"`
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	VenueID              uuid.UUID      `json:"venue_id"`
	EventType            string         `json:"event_type"`
	StartDatetime        time.Time      `json:"start_datetime"`
	EndDatetime          time.Time      `json:"end_datetime"`
	TotalCapacity        int32          `json:"total_capacity"`
	AvailableSeats       int32          `json:"available_seats"`
	BasePrice            string         `json:"base_price"`
	MaxTicketsPerBooking sql.NullInt32  `json:"max_tickets_per_booking"`
	Status               sql.NullString `json:"status"`
	Version              int32          `json:"version"`
}

// UpdateEvent
//
//	UPDATE events
//	SET name = COALESCE($2, name),
//	    description = COALESCE($3, description),
//	    venue_id = COALESCE($4, venue_id),
//	    event_type = COALESCE($5, event_type),
//	    start_datetime = COALESCE($6, start_datetime),
//	    end_datetime = COALESCE($7, end_datetime),
//	    total_capacity = COALESCE($8, total_capacity),
//	    available_seats = COALESCE($9, available_seats),
//	    base_price = COALESCE($10, base_price),
//	    max_tickets_per_booking = COALESCE($11, max_tickets_per_booking),
//	    status = COALESCE($12, status),
//	    updated_at = CURRENT_TIMESTAMP,
//	    version = version + 1
//	WHERE event_id = $1
//	  AND version = $13
//	RETURNING event_id, name, description, venue_id, event_type, start_datetime, end_datetime, total_capacity, available_seats, base_price, max_tickets_per_booking, status, version, created_by, created_at, updated_at
func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.EventID,
		arg.Name,
		arg.Description,
		arg.VenueID,
		arg.EventType,
		arg.StartDatetime,
		arg.EndDatetime,
		arg.TotalCapacity,
		arg.AvailableSeats,
		arg.BasePrice,
		arg.MaxTicketsPerBooking,
		arg.Status,
		arg.Version,
	)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.VenueID,
		&i.EventType,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.TotalCapacity,
		&i.AvailableSeats,
		&i.BasePrice,
		&i.MaxTicketsPerBooking,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventAvailability = `-- name: UpdateEventAvailability :one
UPDATE events
SET available_seats = available_seats - $2,
    version = version + 1,
    updated_at = CURRENT_TIMESTAMP,
    status = CASE
        WHEN (available_seats - $2) = 0 THEN 'sold_out'::text
        ELSE status
    END
WHERE event_id = $1
  AND version = $3
  AND available_seats >= $2
RETURNING event_id, available_seats, status, version
`

type UpdateEventAvailabilityParams struct {
	EventID        uuid.UUID `json:"event_id"`
	AvailableSeats int32     `json:"available_seats"`
	Version        int32     `json:"version"`
}

type UpdateEventAvailabilityRow struct {
	EventID        uuid.UUID      `json:"event_id"`
	AvailableSeats int32          `json:"available_seats"`
	Status         sql.NullString `json:"status"`
	Version        int32          `json:"version"`
}

// UpdateEventAvailability
//
//	UPDATE events
//	SET available_seats = available_seats - $2,
//	    version = version + 1,
//	    updated_at = CURRENT_TIMESTAMP,
//	    status = CASE
//	        WHEN (available_seats - $2) = 0 THEN 'sold_out'::text
//	        ELSE status
//	    END
//	WHERE event_id = $1
//	  AND version = $3
//	  AND available_seats >= $2
//	RETURNING event_id, available_seats, status, version
func (q *Queries) UpdateEventAvailability(ctx context.Context, arg UpdateEventAvailabilityParams) (UpdateEventAvailabilityRow, error) {
	row := q.db.QueryRowContext(ctx, updateEventAvailability, arg.EventID, arg.AvailableSeats, arg.Version)
	var i UpdateEventAvailabilityRow
	err := row.Scan(
		&i.EventID,
		&i.AvailableSeats,
		&i.Status,
		&i.Version,
	)
	return i, err
}
